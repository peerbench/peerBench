CREATE TABLE "ranking_benchmark_quality" (
	"id" integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (sequence name "ranking_benchmark_quality_id_seq" INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START WITH 1 CACHE 1),
	"computation_id" integer NOT NULL,
	"prompt_set_id" integer NOT NULL,
	"quality_score" real NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "ranking_benchmark_quality_computation_id_prompt_set_id_unique" UNIQUE("computation_id","prompt_set_id")
);
--> statement-breakpoint
CREATE TABLE "ranking_computations" (
	"id" integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (sequence name "ranking_computations_id_seq" INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START WITH 1 CACHE 1),
	"min_overlap" integer DEFAULT 5 NOT NULL,
	"account_age_days" integer DEFAULT 7 NOT NULL,
	"computed_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "ranking_contributor_score" (
	"id" integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (sequence name "ranking_contributor_score_id_seq" INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START WITH 1 CACHE 1),
	"computation_id" integer NOT NULL,
	"user_id" uuid NOT NULL,
	"score" real NOT NULL,
	"prompt_count" integer DEFAULT 0 NOT NULL,
	"aligned_review_count" integer DEFAULT 0 NOT NULL,
	"comment_count" integer DEFAULT 0 NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "ranking_contributor_score_computation_id_user_id_unique" UNIQUE("computation_id","user_id")
);
--> statement-breakpoint
CREATE TABLE "ranking_model_performance" (
	"id" integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (sequence name "ranking_model_performance_id_seq" INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START WITH 1 CACHE 1),
	"computation_id" integer NOT NULL,
	"model" text NOT NULL,
	"score" real NOT NULL,
	"prompts_tested_count" integer DEFAULT 0 NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "ranking_model_performance_computation_id_model_unique" UNIQUE("computation_id","model")
);
--> statement-breakpoint
CREATE TABLE "ranking_prompt_quality" (
	"id" integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (sequence name "ranking_prompt_quality_id_seq" INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START WITH 1 CACHE 1),
	"computation_id" integer NOT NULL,
	"prompt_id" uuid NOT NULL,
	"quality_score" real NOT NULL,
	"review_count" integer DEFAULT 0 NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "ranking_prompt_quality_computation_id_prompt_id_unique" UNIQUE("computation_id","prompt_id")
);
--> statement-breakpoint
CREATE TABLE "ranking_reviewer_trust" (
	"id" integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (sequence name "ranking_reviewer_trust_id_seq" INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START WITH 1 CACHE 1),
	"computation_id" integer NOT NULL,
	"user_id" uuid NOT NULL,
	"trust_score" real NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "ranking_reviewer_trust_computation_id_user_id_unique" UNIQUE("computation_id","user_id")
);
--> statement-breakpoint
ALTER TABLE "ranking_benchmark_quality" ADD CONSTRAINT "ranking_benchmark_quality_computation_id_ranking_computations_id_fk" FOREIGN KEY ("computation_id") REFERENCES "public"."ranking_computations"("id") ON DELETE cascade ON UPDATE cascade;--> statement-breakpoint
ALTER TABLE "ranking_benchmark_quality" ADD CONSTRAINT "ranking_benchmark_quality_prompt_set_id_prompt_sets_id_fk" FOREIGN KEY ("prompt_set_id") REFERENCES "public"."prompt_sets"("id") ON DELETE cascade ON UPDATE cascade;--> statement-breakpoint
ALTER TABLE "ranking_contributor_score" ADD CONSTRAINT "ranking_contributor_score_computation_id_ranking_computations_id_fk" FOREIGN KEY ("computation_id") REFERENCES "public"."ranking_computations"("id") ON DELETE cascade ON UPDATE cascade;--> statement-breakpoint
ALTER TABLE "ranking_contributor_score" ADD CONSTRAINT "ranking_contributor_score_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE cascade ON UPDATE cascade;--> statement-breakpoint
ALTER TABLE "ranking_model_performance" ADD CONSTRAINT "ranking_model_performance_computation_id_ranking_computations_id_fk" FOREIGN KEY ("computation_id") REFERENCES "public"."ranking_computations"("id") ON DELETE cascade ON UPDATE cascade;--> statement-breakpoint
ALTER TABLE "ranking_prompt_quality" ADD CONSTRAINT "ranking_prompt_quality_computation_id_ranking_computations_id_fk" FOREIGN KEY ("computation_id") REFERENCES "public"."ranking_computations"("id") ON DELETE cascade ON UPDATE cascade;--> statement-breakpoint
ALTER TABLE "ranking_prompt_quality" ADD CONSTRAINT "ranking_prompt_quality_prompt_id_prompts_id_fk" FOREIGN KEY ("prompt_id") REFERENCES "public"."prompts"("id") ON DELETE cascade ON UPDATE cascade;--> statement-breakpoint
ALTER TABLE "ranking_reviewer_trust" ADD CONSTRAINT "ranking_reviewer_trust_computation_id_ranking_computations_id_fk" FOREIGN KEY ("computation_id") REFERENCES "public"."ranking_computations"("id") ON DELETE cascade ON UPDATE cascade;--> statement-breakpoint
ALTER TABLE "ranking_reviewer_trust" ADD CONSTRAINT "ranking_reviewer_trust_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE cascade ON UPDATE cascade;--> statement-breakpoint
CREATE VIEW "public"."v_current_benchmark_quality" AS (select "ranking_benchmark_quality"."prompt_set_id", "ranking_benchmark_quality"."quality_score", "ranking_computations"."computed_at" from "ranking_benchmark_quality" inner join "ranking_computations" on "ranking_benchmark_quality"."computation_id" = "ranking_computations"."id" where "ranking_benchmark_quality"."computation_id" = (SELECT "latest"."id" FROM (select "id" from "ranking_computations" order by "ranking_computations"."computed_at" DESC limit 1) "latest"));--> statement-breakpoint
CREATE VIEW "public"."v_current_contributor_score" AS (select "ranking_contributor_score"."user_id", "ranking_contributor_score"."score", "ranking_contributor_score"."prompt_count", "ranking_contributor_score"."aligned_review_count", "ranking_contributor_score"."comment_count", "ranking_computations"."computed_at", "user_profile"."display_name", 
        CASE 
          WHEN "auth"."users"."email" IS NOT NULL THEN
            CONCAT(
              '***@',
              SUBSTRING("auth"."users"."email" FROM POSITION('@' IN "auth"."users"."email") + 1)
            )
          ELSE NULL
        END
       as "email" from "ranking_contributor_score" inner join "ranking_computations" on "ranking_contributor_score"."computation_id" = "ranking_computations"."id" left join "auth"."users" on "auth"."users"."id" = "ranking_contributor_score"."user_id" left join "user_profile" on "user_profile"."user_id" = "ranking_contributor_score"."user_id" where "ranking_contributor_score"."computation_id" = (SELECT "latest"."id" FROM (select "id" from "ranking_computations" order by "ranking_computations"."computed_at" DESC limit 1) "latest"));--> statement-breakpoint
CREATE VIEW "public"."v_current_model_performance" AS (select "ranking_model_performance"."model", "ranking_model_performance"."score", "ranking_model_performance"."prompts_tested_count", "ranking_computations"."computed_at" from "ranking_model_performance" inner join "ranking_computations" on "ranking_model_performance"."computation_id" = "ranking_computations"."id" where "ranking_model_performance"."computation_id" = (SELECT "latest"."id" FROM (select "id" from "ranking_computations" order by "ranking_computations"."computed_at" DESC limit 1) "latest"));--> statement-breakpoint
CREATE VIEW "public"."v_current_prompt_quality" AS (select "ranking_prompt_quality"."prompt_id", "ranking_prompt_quality"."quality_score", "ranking_prompt_quality"."review_count", "ranking_computations"."computed_at" from "ranking_prompt_quality" inner join "ranking_computations" on "ranking_prompt_quality"."computation_id" = "ranking_computations"."id" where "ranking_prompt_quality"."computation_id" = (SELECT "latest"."id" FROM (select "id" from "ranking_computations" order by "ranking_computations"."computed_at" DESC limit 1) "latest"));--> statement-breakpoint
CREATE VIEW "public"."v_current_reviewer_trust" AS (select "ranking_reviewer_trust"."user_id", "ranking_reviewer_trust"."trust_score", "ranking_computations"."computed_at", "user_profile"."display_name", 
        CASE 
          WHEN "auth"."users"."email" IS NOT NULL THEN
            CONCAT(
              '***@',
              SUBSTRING("auth"."users"."email" FROM POSITION('@' IN "auth"."users"."email") + 1)
            )
          ELSE NULL
        END
       as "email" from "ranking_reviewer_trust" inner join "ranking_computations" on "ranking_reviewer_trust"."computation_id" = "ranking_computations"."id" left join "auth"."users" on "auth"."users"."id" = "ranking_reviewer_trust"."user_id" left join "user_profile" on "user_profile"."user_id" = "ranking_reviewer_trust"."user_id" where "ranking_reviewer_trust"."computation_id" = (SELECT "latest"."id" FROM (select "id" from "ranking_computations" order by "ranking_computations"."computed_at" DESC limit 1) "latest"));

-- Function to compute all rankings using trust propagation algorithm
CREATE OR REPLACE FUNCTION compute_rankings(
  p_min_overlap INTEGER DEFAULT 5,
  p_account_age_days INTEGER DEFAULT 7
) RETURNS INTEGER AS $$
DECLARE
  v_computation_id INTEGER;
  v_trust_threshold REAL;
  v_qualified_review_threshold REAL := 0.0; -- Will be computed as 50th percentile
BEGIN
  -- Create new computation record
  INSERT INTO ranking_computations (min_overlap, account_age_days)
  VALUES (p_min_overlap, p_account_age_days)
  RETURNING id INTO v_computation_id;

  -- ============================================
  -- STEP 1: COMPUTE REVIEWER TRUST
  -- ============================================
  
  -- Check if this is first run (no previous computations exist)
  IF NOT EXISTS (
    SELECT 1 FROM ranking_computations 
    WHERE id != v_computation_id
    LIMIT 1
  ) THEN
    -- FIRST RUN: Initialize trust based on verified org affiliation and account age
    INSERT INTO ranking_reviewer_trust (computation_id, user_id, trust_score)
    SELECT 
      v_computation_id,
      u.id,
      CASE 
        WHEN otp.user_id IS NOT NULL 
          AND u.created_at <= NOW() - INTERVAL '1 day' * p_account_age_days
        THEN 1.0
        ELSE 0.0
      END AS trust_score
    FROM auth.users u
    LEFT JOIN org_to_people otp ON otp.user_id = u.id
    GROUP BY u.id, otp.user_id, u.created_at;
  ELSE
    -- SUBSEQUENT RUNS: Copy previous trust scores and run single iteration
    INSERT INTO ranking_reviewer_trust (computation_id, user_id, trust_score)
    SELECT 
      v_computation_id,
      rrt.user_id,
      rrt.trust_score
    FROM ranking_reviewer_trust rrt
    INNER JOIN (
      SELECT id 
      FROM ranking_computations 
      WHERE id != v_computation_id
      ORDER BY computed_at DESC 
      LIMIT 1
    ) latest ON rrt.computation_id = latest.id;
    
    -- Run single trust propagation iteration
    -- Compute trust threshold (50th percentile)
    SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY trust_score)
    INTO v_trust_threshold
    FROM ranking_reviewer_trust
    WHERE computation_id = v_computation_id;

    -- Create temporary table for new trust scores
    CREATE TEMP TABLE temp_new_trust AS
    WITH reviewer_opinions AS (
      SELECT 
        qf.user_id,
        qf.prompt_id,
        CASE 
          WHEN qf.opinion = 'positive' THEN 1
          WHEN qf.opinion = 'negative' THEN -1
          ELSE 0
        END AS opinion_value
      FROM quick_feedbacks qf
      WHERE qf.prompt_id IS NOT NULL
    ),
    prompt_consensus AS (
      SELECT 
        ro.prompt_id,
        SUM(rrt.trust_score * ro.opinion_value) / NULLIF(SUM(rrt.trust_score), 0) AS consensus
      FROM reviewer_opinions ro
      INNER JOIN ranking_reviewer_trust rrt 
        ON rrt.user_id = ro.user_id 
        AND rrt.computation_id = v_computation_id
        AND rrt.trust_score > v_trust_threshold
      GROUP BY ro.prompt_id
    ),
    user_alignment AS (
      SELECT 
        ro.user_id,
        COUNT(*) AS total_reviews,
        SUM(
          CASE 
            WHEN SIGN(ro.opinion_value) = SIGN(pc.consensus) THEN 1
            ELSE 0
          END
        )::REAL / NULLIF(COUNT(*), 0) AS alignment_rate
      FROM reviewer_opinions ro
      INNER JOIN prompt_consensus pc ON pc.prompt_id = ro.prompt_id
      WHERE pc.consensus IS NOT NULL
      GROUP BY ro.user_id
      HAVING COUNT(*) >= p_min_overlap
    )
    SELECT 
      u.id AS user_id,
      GREATEST(0, COALESCE(ua.alignment_rate, rrt.trust_score)) AS new_trust_score
    FROM auth.users u
    LEFT JOIN user_alignment ua ON ua.user_id = u.id
    INNER JOIN ranking_reviewer_trust rrt 
      ON rrt.user_id = u.id 
      AND rrt.computation_id = v_computation_id;

    -- Update trust scores
    UPDATE ranking_reviewer_trust rrt
    SET trust_score = tnt.new_trust_score
    FROM temp_new_trust tnt
    WHERE rrt.user_id = tnt.user_id 
      AND rrt.computation_id = v_computation_id;

    DROP TABLE temp_new_trust;
  END IF;

  -- Compute final threshold for use in quality calculations
  SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY trust_score)
  INTO v_trust_threshold
  FROM ranking_reviewer_trust
  WHERE computation_id = v_computation_id;

  -- ============================================
  -- STEP 2: COMPUTE PROMPT QUALITY
  -- ============================================
  
  INSERT INTO ranking_prompt_quality (computation_id, prompt_id, quality_score, review_count)
  SELECT 
    v_computation_id,
    qf.prompt_id,
    -- Normalize to [0, 1]
    (
      SUM(
        rrt.trust_score * 
        CASE 
          WHEN qf.opinion = 'positive' THEN 1
          WHEN qf.opinion = 'negative' THEN -1
          ELSE 0
        END
      ) / NULLIF(SUM(rrt.trust_score), 0) + 1
    ) / 2.0 AS quality_score,
    COUNT(*) AS review_count
  FROM quick_feedbacks qf
  INNER JOIN ranking_reviewer_trust rrt 
    ON rrt.user_id = qf.user_id 
    AND rrt.computation_id = v_computation_id
    AND rrt.trust_score > v_trust_threshold
  WHERE qf.prompt_id IS NOT NULL
  GROUP BY qf.prompt_id
  HAVING COUNT(*) > 0;

  -- ============================================
  -- STEP 3: COMPUTE BENCHMARK QUALITY
  -- ============================================
  
  INSERT INTO ranking_benchmark_quality (computation_id, prompt_set_id, quality_score)
  SELECT 
    v_computation_id,
    psp.prompt_set_id,
    AVG(rpq.quality_score) AS quality_score
  FROM prompt_set_prompts psp
  INNER JOIN ranking_prompt_quality rpq 
    ON rpq.prompt_id = psp.prompt_id 
    AND rpq.computation_id = v_computation_id
  WHERE psp.status = 'included'
  GROUP BY psp.prompt_set_id
  HAVING COUNT(*) > 0;

  -- ============================================
  -- STEP 4: COMPUTE MODEL PERFORMANCE
  -- ============================================
  
  INSERT INTO ranking_model_performance (computation_id, model, score, prompts_tested_count)
  WITH model_responses AS (
    SELECT 
      COALESCE(km.name, pm.model_id) AS model,
      r.prompt_id,
      s.score AS response_score,
      rpq.quality_score,
      rpq.review_count
    FROM responses r
    INNER JOIN scores s ON s.response_id = r.id
    INNER JOIN provider_models pm ON pm.id = r.model_id
    LEFT JOIN known_models km ON km.id = pm.known_model_id
    INNER JOIN ranking_prompt_quality rpq 
      ON rpq.prompt_id = r.prompt_id 
      AND rpq.computation_id = v_computation_id
    WHERE rpq.quality_score > 0.5 -- Only quality prompts
  ),
  model_scores AS (
    SELECT 
      model,
      prompt_id,
      response_score,
      quality_score * (1 + LN(5.0 * review_count) - LN(5.0)) AS prompt_weight
    FROM model_responses
  )
  SELECT 
    v_computation_id,
    model,
    SUM(response_score * prompt_weight) / NULLIF(SUM(prompt_weight), 0) AS score,
    COUNT(DISTINCT prompt_id) AS prompts_tested_count
  FROM model_scores
  GROUP BY model
  HAVING COUNT(*) > 0;

  -- ============================================
  -- STEP 5: COMPUTE CONTRIBUTOR SCORES
  -- ============================================
  
  WITH contributor_prompts AS (
    SELECT 
      hr.uploader_id AS user_id,
      COUNT(DISTINCT p.id) AS prompt_count,
      SUM(rpq.quality_score) AS total_prompt_quality
    FROM prompts p
    INNER JOIN hash_registrations hr 
      ON hr.cid = p.hash_cid_registration 
      AND hr.sha256 = p.hash_sha256_registration
    INNER JOIN ranking_prompt_quality rpq 
      ON rpq.prompt_id = p.id 
      AND rpq.computation_id = v_computation_id
    GROUP BY hr.uploader_id
  ),
  contributor_reviews AS (
    SELECT 
      qf.user_id,
      COUNT(*) AS aligned_review_count
    FROM quick_feedbacks qf
    INNER JOIN ranking_prompt_quality rpq 
      ON rpq.prompt_id = qf.prompt_id 
      AND rpq.computation_id = v_computation_id
    WHERE 
      (qf.opinion = 'positive' AND rpq.quality_score > 0.5) OR
      (qf.opinion = 'negative' AND rpq.quality_score < 0.5)
    GROUP BY qf.user_id
  ),
  contributor_comments AS (
    SELECT user_id, COUNT(*) AS comment_count
    FROM (
      SELECT user_id FROM prompt_comments
      UNION ALL
      SELECT user_id FROM response_comments
      UNION ALL
      SELECT user_id FROM score_comments
    ) all_comments
    GROUP BY user_id
  ),
  max_values AS (
    SELECT 
      MAX(COALESCE(cp.total_prompt_quality, 0)) AS max_prompt_quality,
      MAX(COALESCE(cr.aligned_review_count, 0)) AS max_review_count,
      MAX(COALESCE(cc.comment_count, 0)) AS max_comment_count
    FROM auth.users u
    LEFT JOIN contributor_prompts cp ON cp.user_id = u.id
    LEFT JOIN contributor_reviews cr ON cr.user_id = u.id
    LEFT JOIN contributor_comments cc ON cc.user_id = u.id
  )
  INSERT INTO ranking_contributor_score 
    (computation_id, user_id, score, prompt_count, aligned_review_count, comment_count)
  SELECT 
    v_computation_id,
    u.id,
    CASE 
      WHEN mv.max_prompt_quality = 0 AND mv.max_review_count = 0 AND mv.max_comment_count = 0
      THEN 0
      ELSE 
        0.7 * COALESCE(cp.total_prompt_quality, 0) / NULLIF(mv.max_prompt_quality, 0) +
        0.2 * COALESCE(cr.aligned_review_count, 0) / NULLIF(mv.max_review_count, 0) +
        0.1 * COALESCE(cc.comment_count, 0) / NULLIF(mv.max_comment_count, 0)
    END AS score,
    COALESCE(cp.prompt_count, 0),
    COALESCE(cr.aligned_review_count, 0),
    COALESCE(cc.comment_count, 0)
  FROM auth.users u
  CROSS JOIN max_values mv
  LEFT JOIN contributor_prompts cp ON cp.user_id = u.id
  LEFT JOIN contributor_reviews cr ON cr.user_id = u.id
  LEFT JOIN contributor_comments cc ON cc.user_id = u.id
  WHERE 
    cp.user_id IS NOT NULL OR 
    cr.user_id IS NOT NULL OR 
    cc.user_id IS NOT NULL;

  -- ============================================
  -- CLEANUP: Remove old computations (keep last 30 days)
  -- ============================================
  
  DELETE FROM ranking_computations
  WHERE computed_at < NOW() - INTERVAL '30 days'
    AND id != v_computation_id;

  RETURN v_computation_id;
END;
$$ LANGUAGE plpgsql;

-- Create a comment explaining the function
COMMENT ON FUNCTION compute_rankings IS 
'Computes all ranking metrics using trust propagation algorithm.
Trust propagation strategy:
- First run: Bootstrap trust from verified org affiliations (no propagation)
- Subsequent runs: Copy previous trust + single propagation iteration
Parameters:
- p_min_overlap: Minimum overlapping reviews for trust calculation (default 5)
- p_account_age_days: Minimum account age in days for initial trust (default 7)
Returns: computation_id of the newly created ranking computation';

